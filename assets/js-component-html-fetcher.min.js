(()=>{"use strict";class t extends HTMLElement{#t;#e="[[value]]";#i={undefined:"undefined",available:"available",not_available:"not-available",does_not_exist:"does-not-exist"};#s="js-product-option-";dataAttributes={};optionName;$productSection;constructor(t){super(),this.#t=t,this.dataAttributes={name:`data-${t}-name`,valueLabel:`data-${t}-value`,classPrefix:`data-${t}-class-prefix`}}connectedCallbackStart(){if(this.optionName=this.getAttribute(this.dataAttributes.name),void 0===this.optionName||""===this.optionName)throw new Error(`[${this.#t}] [Product option name is not set]`);if(this.$productSection=this.closest("product-section"),!this.$productSection)throw new Error(`[${this.#t}] [A related product-section element is not found]`);this.#s=this.getAttribute(this.dataAttributes.classPrefix)||this.#s}connectedCallbackEnd(){this.$productSection.addEventListener("statechange",(()=>{this.render()})),this.$productSection.state&&this.render()}getOptionState(){return this.$productSection.state.optionsValues.find((t=>t.name===this.optionName))}#a(t){const e=this.$productSection.state.optionsAvailability[this.optionName];let i=this.#i.undefined;return e&&(t in e?e[t]?this.#i.available:this.#i.not_available:this.#i.does_not_exist),i}addAvailabilityClass(t,e){t.classList.remove(...Object.values(this.#i).map((t=>this.#s+t))),t.classList.add(this.#s+this.#a(e))}render(){const t=this.getOptionState();if(t){const e=t.value;this.querySelectorAll(`[${this.dataAttributes.valueLabel}]`).forEach((t=>{if(!e)return void(t.innerHTML="");const i=t.getAttribute(this.dataAttributes.valueLabel)||this.#e;t.innerHTML=i.replaceAll(this.#e,e)}))}}}const e="html-fetcher",i={EAGER:"eager",LAZY:"lazy"},s="htmlupdate",a="data-html-fetcher-link",r="data-html-fetcher-loading-class";class l extends HTMLElement{#r;#l;#n=i.EAGER;#o;constructor(){super(),this.#o=new IntersectionObserver(((t,e)=>{t[0].isIntersecting&&(e.unobserve(this),this.updateHTML())}),{rootMargin:"0px 0px 0px 0px"}),this.addEventListener("click",(t=>{for(let e=t.target;e&&e!==this;e=e.parentElement)if(e.hasAttribute(a)){t.preventDefault();let i=e.getAttribute(a)||e.href;return void this.setUrl(i)}}))}connectedCallback(){const t=this.getAttribute("loading");Object.values(i).includes(t)&&(this.#n=t);const e=this.getAttribute("href");e&&this.setUrl(e)}setUrl(t){this.#r=t,this.#n!==i.EAGER?this.#o.observe(this):this.updateHTML()}async updateHTML(){this.#l&&this.#l.abort(),this.#l=new AbortController;try{this.#h(!0);const t=await fetch(this.#r,{signal:this.#l.signal});if(!t.ok)throw new Error(`Response error from the "${t.url}" URL`);let i=e;this.id&&(i+=`[id="${this.id}"]`);const a=await t.text(),r=(new DOMParser).parseFromString(a,"text/html").querySelectorAll(i);r.length>0?(this.innerHTML=r[0].innerHTML,r.length>1&&console.error(`[html-fetcher] [A few html-fetchers in the response. Use unique ID for each html-fetcher. Query Selector: "${i}"]`,this)):this.innerHTML=a,this.dispatchEvent(new CustomEvent(s))}catch(t){if("AbortError"!==t.name)throw t}this.#h(!1)}#h(t){((t,e,i)=>{t.querySelectorAll(`[${e}]`).forEach((t=>{const s=t.getAttribute(e);s&&(i?t.classList.add(s):t.classList.remove(s))}))})(this,r,t)}}customElements.define(e,l)})();