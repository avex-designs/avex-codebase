/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/helpers.js":
/*!********************************!*\
  !*** ./src/scripts/helpers.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "getCollectionUrl": () => (/* binding */ getCollectionUrl),
/* harmony export */   "getShopifySection": () => (/* binding */ getShopifySection),
/* harmony export */   "isInViewport": () => (/* binding */ isInViewport),
/* harmony export */   "loadJS": () => (/* binding */ loadJS),
/* harmony export */   "parseTag": () => (/* binding */ parseTag),
/* harmony export */   "serializeForm": () => (/* binding */ serializeForm),
/* harmony export */   "toggleClassFromAttribute": () => (/* binding */ toggleClassFromAttribute)
/* harmony export */ });
const getShopifySection = ($element) => {
  const sectionPrefix = "shopify-section-";
  const $section = $element.closest(`[id^="${sectionPrefix}"]`);
  if (!$section) return [null, null];
  const sectionId = $section.id.replace(sectionPrefix, "");
  return [sectionId, $section];
};

const toggleClassFromAttribute = ($context, attributeName, on) => {
  $context.querySelectorAll(`[${attributeName}]`).forEach(($element) => {
    const className = $element.getAttribute(attributeName);
    if (className) {
      if (on) $element.classList.add(className);
      else $element.classList.remove(className);
    }
  });
};

const isInViewport = (elem) => {
  const bounding = elem && elem.getBoundingClientRect();
  return bounding && bounding.top < window.innerHeight && bounding.bottom >= 0;
};

function serializeForm(form) {
  let obj = {};
  let formData = new FormData(form);

  for (let key of formData.keys()) {
    obj[key] = formData.get(key);
  }

  return obj;
}

function debounce(fn, wait) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), wait);
  };
}

function parseTag(url) {
  const regex = /[^/]+$/;
  return url.match(regex)[0];
}

function getCollectionUrl(url) {
  const regex = /\/\S+\//;
  return url.match(regex)[0];
}

async function loadJS(FILE_URL, cb) {
  let $script = document.createElement("script");

  $script.setAttribute("src", FILE_URL);
  $script.setAttribute("type", "text/javascript");

  document.body.appendChild($script);

  cb && cb($script);
  return new Promise((resolve, reject) => {
    $script.addEventListener("load", () => {
      resolve(true);
    });
    $script.addEventListener("error", () => {
      reject(false);
    });
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!************************************************!*\
  !*** ./src/scripts/components/html-fetcher.js ***!
  \************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/scripts/helpers.js");
// The html-fetcher fetches HTML from the URL passed in the "href" parameter
// and places it inside itself.
// If the fetched HTML contains "html-fetcher" with the same ID,
// then only its inner HTML will be taken.
//
// Use cases:
// * "product-recommendations" section;
// * default pagination ajaxified, such as customer order history pagination;
// * popups that load data from Shopify page or another source.
//
// Provide unique ID for "html-fetcher" elements is possible
// to avoid the situation when the fetched HTML contains more than one "html-fetcher" elements,
// thus it is not clear what element to take inner HTML from.
// Good practice to use {{ section.id }} in its ID
// if you use it within a Shopify section:
// <html-fetcher id="html-fetcher-pagination-{{ section.id }}"></html-fetcher>
//
// In order to load HTML from the "/my/url" URL
// right after the element appears on the page --
// use the loading="eager" attribute:
// <html-fetcher id="my-fetcher-{{ section.id }}" href="/my/url" loading="eager"></html-fetcher>
//
// In order to lazy load HTML (when the element appears in the viewport) --
// use the loading="lazy" attribute,
// as used in the "product recommendations" section:
// <html-fetcher id="my-fetcher-{{ section.id }}" href="/my/url" loading="lazy"></html-fetcher>
//
// In order to trigger HTML loading when a user clicks on a link withing the component --
// apply the "data-html-fetcher-link" attribute to the link.
// If the HTML should be loaded from the page, same as the link's href attribute,
// leave the "data-html-fetcher-link" empty:
// <html-fetcher id="my-fetcher-{{ section.id }}">
//   <a href="/my/url">My link</a>
// </html-fetcher>
// If the page to load HTML is different,
// provide the page as the value of the "data-html-fetcher-link" attribute:
// <html-fetcher id="my-fetcher-{{ section.id }}">
//   <a
//     href="{{ paginate.previous.url }}"
//     data-html-fetcher-link="{{ paginate.previous.url }}&section_id={{ section.id }}">
//   Previous
//   </a>
// </html-fetcher>
//
// In order to add a CSS class to an element when the "html-fetcher" is loading,
// use the "data-html-fetcher-loading-class" attribute:
// <html-fetcher id="my-fetcher-{{ section.id }}">
//   <div class="my-class" data-html-fetcher-loading-class="js-loading"></div>
// </html-fetcher>
//
// In order to trigger loading HTML via JavaScript,
// leave the "href" parameter empty and use the "setUrl" method:
// <html-fetcher id="my-fetcher-{{ section.id }}"></html-fetcher>
// <script>
//   document.querySelector(`#my-fetcher-${section_id}`).setUrl("/my/url");
// </script>
//
// In order to subscribe to element's HTML update, use the "htmlupdate" event:
// <html-fetcher id="my-fetcher-{{ section.id }}"></html-fetcher>
// <script>
//   const $htmlFetcher = document.querySelector(`#my-fetcher-${section_id}`);
//   $htmlFetcher.addEventListener('htmlupdate', (event) => {
//     console.log("htmlupdate");
//   });
// </script>



const elementName = "html-fetcher";
const loadingTypes = {
  EAGER: "eager",
  LAZY: "lazy",
};

const events = {
  HTML_UPDATE: "htmlupdate",
};

const attributes = {
  fetcherLink: "data-html-fetcher-link",
  loadingClass: "data-html-fetcher-loading-class",
};

class HTMLFetcher extends HTMLElement {
  #url;
  #abortController;
  #loading = loadingTypes.EAGER;
  #intersectionObserver;

  constructor() {
    super();
    this.#intersectionObserver = new IntersectionObserver(
      (entries, observer) => {
        if (!entries[0].isIntersecting) return;
        observer.unobserve(this);
        this.updateHTML();
      },
      {
        rootMargin: "0px 0px 0px 0px",
      }
    );

    this.addEventListener("click", (event) => {
      for (
        let $target = event.target;
        $target && $target !== this;
        $target = $target.parentElement
      ) {
        if ($target.hasAttribute(attributes.fetcherLink)) {
          event.preventDefault();
          let url =
            $target.getAttribute(attributes.fetcherLink) || $target.href;
          this.setUrl(url);
          return;
        }
      }
    });
  }

  connectedCallback() {
    const loading = this.getAttribute("loading");
    if (Object.values(loadingTypes).includes(loading)) {
      this.#loading = loading;
    }

    const url = this.getAttribute("href");
    if (!url) return;

    this.setUrl(url);
  }

  setUrl(url) {
    this.#url = url;
    if (this.#loading === loadingTypes.EAGER) {
      this.updateHTML();
      return;
    }
    this.#intersectionObserver.observe(this);
  }

  async updateHTML() {
    if (this.#abortController) {
      this.#abortController.abort();
    }
    this.#abortController = new AbortController();
    try {
      this.#toggleLoadingClasses(true);
      const response = await fetch(this.#url, {
        signal: this.#abortController.signal,
      });
      if (!response.ok)
        throw new Error(`Response error from the "${response.url}" URL`);

      let queryDOM = elementName;
      if (this.id) queryDOM += `[id="${this.id}"]`;
      const html = await response.text();
      const newdocument = new DOMParser().parseFromString(html, "text/html");
      const $newElementsList = newdocument.querySelectorAll(queryDOM);
      if ($newElementsList.length > 0) {
        this.innerHTML = $newElementsList[0].innerHTML;
        if ($newElementsList.length > 1) {
          console.error(
            `[html-fetcher] [A few html-fetchers in the response. Use unique ID for each html-fetcher. Query Selector: "${queryDOM}"]`,
            this
          );
        }
      } else {
        this.innerHTML = html;
      }
      this.dispatchEvent(new CustomEvent(events.HTML_UPDATE));
    } catch (error) {
      if (error.name !== "AbortError") {
        throw error;
      }
    }
    this.#toggleLoadingClasses(false);
  }

  #toggleLoadingClasses(on) {
    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.toggleClassFromAttribute)(this, attributes.loadingClass, on);
  }
}

customElements.define(elementName, HTMLFetcher);

})();

/******/ })()
;