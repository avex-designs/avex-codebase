(()=>{"use strict";const t="html-fetcher",e={EAGER:"eager",LAZY:"lazy"},r="htmlupdate",s="data-html-fetcher-link",i="data-html-fetcher-loading-class";class n extends HTMLElement{_url;_abortController;_loading=e.EAGER;_intersectionObserver;constructor(){super(),this._intersectionObserver=new IntersectionObserver(((t,e)=>{t[0].isIntersecting&&(e.unobserve(this),this.updateHTML())}),{rootMargin:"0px 0px 0px 0px"}),this.addEventListener("click",(t=>{for(let e=t.target;e&&e!==this;e=e.parentElement)if(e.hasAttribute(s)){t.preventDefault();let r=e.getAttribute(s)||e.href;return void this.setUrl(r)}}))}connectedCallback(){const t=this.getAttribute("loading");Object.values(e).includes(t)&&(this._loading=t);const r=this.getAttribute("href");r&&this.setUrl(r)}setUrl(t){this._url=t,this._loading!==e.EAGER?this._intersectionObserver.observe(this):this.updateHTML()}async updateHTML(){this._abortController&&this._abortController.abort(),this._abortController=new AbortController;try{this._toggleLoadingClasses(!0);const e=await fetch(this._url,{signal:this._abortController.signal});if(!e.ok)throw new Error(`Response error from the "${e.url}" URL`);let s=t;this.id&&(s+=`[id="${this.id}"]`);const i=await e.text(),n=(new DOMParser).parseFromString(i,"text/html").querySelectorAll(s);n.length>0?(this.innerHTML=n[0].innerHTML,n.length>1&&console.error(`[html-fetcher] [A few html-fetchers in the response. Use unique ID for each html-fetcher. Query Selector: "${s}"]`,this)):this.innerHTML=i,this.dispatchEvent(new CustomEvent(r))}catch(t){if("AbortError"!==t.name)throw t}this._toggleLoadingClasses(!1)}_toggleLoadingClasses(t){((t,e,r)=>{t.querySelectorAll(`[${e}]`).forEach((t=>{const s=t.getAttribute(e);s&&(r?t.classList.add(s):t.classList.remove(s))}))})(this,i,t)}}customElements.define(t,n)})();