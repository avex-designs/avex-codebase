/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/helpers.js":
/*!********************************!*\
  !*** ./src/scripts/helpers.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProductOption": () => (/* binding */ ProductOption),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "getCollectionUrl": () => (/* binding */ getCollectionUrl),
/* harmony export */   "getShopifySection": () => (/* binding */ getShopifySection),
/* harmony export */   "isInViewport": () => (/* binding */ isInViewport),
/* harmony export */   "loadJS": () => (/* binding */ loadJS),
/* harmony export */   "parseTag": () => (/* binding */ parseTag),
/* harmony export */   "serializeForm": () => (/* binding */ serializeForm),
/* harmony export */   "toggleClassFromAttribute": () => (/* binding */ toggleClassFromAttribute)
/* harmony export */ });
const getShopifySection = ($element) => {
  const sectionPrefix = "shopify-section-";
  const $section = $element.closest(`[id^="${sectionPrefix}"]`);
  if (!$section) return [null, null];
  const sectionId = $section.id.replace(sectionPrefix, "");
  return [sectionId, $section];
};

const toggleClassFromAttribute = ($context, attributeName, on) => {
  $context.querySelectorAll(`[${attributeName}]`).forEach(($element) => {
    const className = $element.getAttribute(attributeName);
    if (className) {
      if (on) $element.classList.add(className);
      else $element.classList.remove(className);
    }
  });
};

const isInViewport = (elem) => {
  const bounding = elem && elem.getBoundingClientRect();
  return bounding && bounding.top < window.innerHeight && bounding.bottom >= 0;
};

function serializeForm(form) {
  let obj = {};
  let formData = new FormData(form);

  for (let key of formData.keys()) {
    obj[key] = formData.get(key);
  }

  return obj;
}

function debounce(fn, wait) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), wait);
  };
}

function parseTag(url) {
  const regex = /[^/]+$/;
  return url.match(regex)[0];
}

function getCollectionUrl(url) {
  const regex = /\/\S+\//;
  return url.match(regex)[0];
}

async function loadJS(FILE_URL, cb) {
  let $script = document.createElement("script");

  $script.setAttribute("src", FILE_URL);
  $script.setAttribute("type", "text/javascript");

  document.body.appendChild($script);

  cb && cb($script);
  return new Promise((resolve, reject) => {
    $script.addEventListener("load", () => {
      resolve(true);
    });
    $script.addEventListener("error", () => {
      reject(false);
    });
  });
}

class ProductOption extends HTMLElement {
  #elementName;
  #valueLabelPlaceholder = "[[value]]";
  #availabilityStatuses = {
    undefined: "undefined",
    available: "available",
    not_available: "not-available",
    does_not_exist: "does-not-exist",
  };
  #classPrefix = "js-product-option-";

  dataAttributes = {};
  optionName;
  $productSection;

  constructor(elementName) {
    super();
    this.#elementName = elementName;
    this.dataAttributes = {
      name: `data-${elementName}-name`,
      valueLabel: `data-${elementName}-value`,
      classPrefix: `data-${elementName}-class-prefix`,
    };
  }

  connectedCallbackStart() {
    this.optionName = this.getAttribute(this.dataAttributes.name);
    if (this.optionName === undefined || this.optionName === "")
      throw new Error(
        `[${this.#elementName}] [Product option name is not set]`
      );

    this.$productSection = this.closest("product-section");
    if (!this.$productSection)
      throw new Error(
        `[${
          this.#elementName
        }] [A related product-section element is not found]`
      );

    this.#classPrefix =
      this.getAttribute(this.dataAttributes.classPrefix) || this.#classPrefix;
  }

  connectedCallbackEnd() {
    this.$productSection.addEventListener("statechange", () => {
      this.render();
    });
    if (this.$productSection.state) this.render();
  }

  getOptionState() {
    return this.$productSection.state.optionsValues.find(
      (option) => option.name === this.optionName
    );
  }

  #getValueAvailability(value) {
    const availability =
      this.$productSection.state.optionsAvailability[this.optionName];
    let status = this.#availabilityStatuses.undefined;
    if (availability) {
      if (!(value in availability))
        status = this.#availabilityStatuses.does_not_exist;
      else if (availability[value])
        status = this.#availabilityStatuses.available;
      else status = this.#availabilityStatuses.not_available;
    }
    return status;
  }

  addAvailabilityClass($element, value) {
    $element.classList.remove(
      ...Object.values(this.#availabilityStatuses).map(
        (status) => this.#classPrefix + status
      )
    );
    $element.classList.add(
      this.#classPrefix + this.#getValueAvailability(value)
    );
  }

  render() {
    const option = this.getOptionState();
    if (option) {
      const value = option.value;
      this.querySelectorAll(`[${this.dataAttributes.valueLabel}]`).forEach(
        ($element) => {
          if (!value) {
            $element.innerHTML = "";
            return;
          }
          const template =
            $element.getAttribute(this.dataAttributes.valueLabel) ||
            this.#valueLabelPlaceholder;
          $element.innerHTML = template.replaceAll(
            this.#valueLabelPlaceholder,
            value
          );
        }
      );
    }
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***************************************************!*\
  !*** ./src/scripts/components/product-section.js ***!
  \***************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/scripts/helpers.js");


const ELEMENT_NAME = "product-section";
const attributes = {
  json: `data-${ELEMENT_NAME}-json`,
  area: `data-${ELEMENT_NAME}-area`,
  doesNotExistText: `data-${ELEMENT_NAME}-doesnotexist`,
  loadingClass: `data-${ELEMENT_NAME}-loading-class`,
  errorMessage: `data-${ELEMENT_NAME}-error`,
};
const Events = {
  STATECHANGE: "statechange",
};

class ProductSection extends HTMLElement {
  // if #variantId is undefinded, means the element is not initialized
  // if #variantId is 0, means not all the options are selected so no specific variant is chosen
  // if #variantId is null, means all the options are selected but no variant exists for the options' combination
  #variantId;

  #data;

  // The #optionsValues keeps the state of options' values, where the index is the option's index.
  // [
  //   0 => {
  //      name: 'Size',
  //      value: 'Medium'
  //   }
  // ]
  #optionsValues = [];

  // The #optionsHierarchy keeps the info which option is considered as the first option, which is the second etc.
  // The index of this array is hierarchy number, the value -- is the index of a related option:
  // [
  //   0 => 1,
  //   1 => 2,
  //   2 => 0
  // ]
  // The example above means the option with the index 1 is considered as the first option,
  // the option with the index 2 is the second option,
  // the option with the index 0 is the third option.
  //
  // 99.9% the hierarchy will match the options order:
  // [
  //   0 => 0,
  //   1 => 1,
  //   2 => 2
  // ]
  #optionsHierarchy = [];

  // {
  //   'Size': {
  //     'Medium': true,
  //     'Large': false
  //   },
  //   'Color': {
  //     'Red': true,
  //     'Blue': true
  //   }
  // }
  #optionsAvailability = {};

  // List of form inputs that send variant ID to the server
  #$variantInputs;
  #$addToCartButtons;

  #isHydration = false;

  // to abort previous Section API fetch requests
  #abortController;

  // keeps the latest HTML of the component to get back to it if a fetch error occurs
  #latestHTML;

  constructor() {
    super();
  }

  connectedCallback() {
    this.addEventListener(Events.STATECHANGE, this.#render.bind(this));
    this.#latestHTML = `<div>${this.outerHTML}</div>`;
    this.#hydrate();
  }

  #hydrate() {
    this.#isHydration = true;

    try {
      const $jsonScript = this.querySelector(`[${attributes.json}]`);
      if (!$jsonScript)
        throw new Error(
          `[${ELEMENT_NAME}] [The mandatory ${attributes.json} element is not found]`
        );
      this.#data = JSON.parse($jsonScript.innerHTML);

      // set the #optionsHierarchy to match the options order
      this.#optionsHierarchy = this.#data.product.options.map(
        (option, index) => index
      );

      if (
        !("requestURL" in this.#data.section) ||
        !("sectionId" in this.#data.section)
      )
        throw new Error(
          `[${ELEMENT_NAME}] [Wrong ${attributes.json} data structure]`
        );

      this.#$variantInputs = this.querySelectorAll("input[name='id']");

      this.#$addToCartButtons = this.querySelectorAll("[name='add']");

      this.setVariantId(this.#data.section.variantId || 0);
    } catch (e) {
      this.#isHydration = false;
      throw e;
    }

    this.#isHydration = false;
  }

  /**
   * Accepts variant ID as a number.
   * If it is not a number, variant ID will be considered as 0
   */
  setVariantId(variantId) {
    let optionsValues;

    if (variantId > 0) {
      const variant = this.#data.product.variants.find(
        (variant) => variant.id === variantId
      );
      if (!variant)
        throw new Error(
          `[${ELEMENT_NAME}] [The variant "${variantId}" is not found in the product data object]`
        );

      optionsValues = this.#data.product.options.map((name, index) => {
        return {
          name,
          value: variant.options[index],
        };
      });

      return this.#changeState({ variantId, optionsValues });
    }

    return this.#changeState({
      variantId: 0,
      optionsValues: this.#data.product.options.map((name) => {
        return {
          name,
          value: null,
        };
      }),
    });
  }

  /**
   * Accepts an object where the keys are option names that should be changed
   * and the values are new option values:
   * {
   *    color: 'Red'
   * }
   */
  setOptions(changedOptions) {
    let areAllSelected = true;

    const optionsValues = this.#optionsValues.map(({ name, value }) => {
      let newValue = name in changedOptions ? changedOptions[name] : value;
      if (newValue === null || newValue === undefined || newValue === "") {
        newValue = null;
        areAllSelected = false;
      }
      return {
        name,
        value: newValue,
      };
    });

    if (!areAllSelected)
      return this.#changeState({ variantId: 0, optionsValues });

    const variant = this.#data.product.variants.find((variant) => {
      for (let i = 0; i < optionsValues.length; i++) {
        if (optionsValues[i].value !== variant.options[i]) {
          return false;
        }
      }
      return true;
    });

    const variantId = variant ? variant.id : null;
    return this.#changeState({ variantId, optionsValues });
  }

  #changeState({ variantId, optionsValues }) {
    const isVariantChanged = variantId !== this.#variantId;
    const areOptionsChanged = optionsValues.reduce((acc, el, index) => {
      return (
        acc ||
        el.name !== this.#optionsValues[index]?.name ||
        el.value !== this.#optionsValues[index]?.value
      );
    }, false);

    this.#variantId = variantId;
    this.#optionsValues = optionsValues;

    const isAvailabilityChanged =
      areOptionsChanged || this.#isHydration
        ? this.#updateAvailability()
        : false;

    if (isVariantChanged || areOptionsChanged || isAvailabilityChanged) {
      this.dispatchEvent(
        new CustomEvent(Events.STATECHANGE, {
          detail: {
            isVariantChanged,
          },
        })
      );
    }
  }

  async #render(event) {
    if (this.#abortController) {
      this.#abortController.abort();
      this.#abortController = undefined;
    }

    this.#$variantInputs.forEach(($input) => {
      $input.value = this.#variantId || "";
      $input.setAttribute("value", this.#variantId || "");
    });

    this.#toggleLoadingClasses(false);
    this.#showErrorMessages(false);

    if (!event.detail.isVariantChanged || this.#isHydration) return;

    if (this.#variantId === null) {
      this.#$addToCartButtons.forEach(($button) => {
        $button.disabled = true;
      });
      this.querySelectorAll(`[${attributes.doesNotExistText}]`).forEach(
        ($element) => {
          const text = $element.getAttribute(attributes.doesNotExistText);
          if (text) {
            $element.textContent = text;
          }
        }
      );
      return;
    }

    if (this.#data.section.updateURL) {
      window.history.replaceState(
        {},
        "",
        `${this.#data.section.requestURL}${
          this.#data.section.requestURL.indexOf("?") > -1 ? "&" : "?"
        }${this.#variantId > 0 ? `variant=${this.#variantId}` : ""}`
      );
    }

    const url = `${this.#data.section.requestURL}${
      this.#data.section.requestURL.indexOf("?") > -1 ? "&" : "?"
    }${this.#variantId > 0 ? `variant=${this.#variantId}&` : ""}section_id=${
      this.#data.section.sectionId
    }`;

    this.#abortController = new AbortController();

    this.#$addToCartButtons.forEach(($button) => {
      $button.disabled = true;
    });

    this.#toggleLoadingClasses(true);

    try {
      const response = await fetch(url, {
        signal: this.#abortController.signal,
      });
      if (!response.ok)
        throw new Error(
          `[${ELEMENT_NAME}] [Response error from the "${response.url}" URL]`
        );

      const html = await response.text();
      this.#changeHTML(html);
      this.#toggleLoadingClasses(false);
    } catch (error) {
      if (error.name !== "AbortError") {
        this.#changeHTML(this.#latestHTML);
        this.#toggleLoadingClasses(false);
        this.#showErrorMessages(true);
        throw error;
      }
    }
  }

  #toggleLoadingClasses(on) {
    (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.toggleClassFromAttribute)(this, attributes.loadingClass, on);
  }

  #showErrorMessages(show) {
    this.querySelectorAll(`[${attributes.errorMessage}]`).forEach(
      ($element) => {
        $element.hidden = !show;
      }
    );
  }

  #changeHTML(html) {
    const newDocument = new DOMParser().parseFromString(html, "text/html");
    const $newElement = newDocument.querySelector(
      `${ELEMENT_NAME}${this.id ? "#" + this.id : ""}`
    );
    if (!$newElement)
      throw new Error(
        `[${ELEMENT_NAME}] [The "${ELEMENT_NAME}" element is not found]`
      );
    this.#latestHTML = html;

    this.querySelector(`[${attributes.json}]`).innerHTML =
      $newElement.querySelector(`[${attributes.json}]`).innerHTML;

    const $curAreas = Array.from(this.querySelectorAll(`[${attributes.area}]`));
    const $newAreas = Array.from(
      $newElement.querySelectorAll(`[${attributes.area}]`)
    );

    let hasShopifyPaymentButton = false;
    if ($curAreas.length !== $newAreas.length) {
      console.warn(
        `[${ELEMENT_NAME}] [Previous "${attributes.area}" elements don't match the new received ones. The HTML of the component will be replaced completely.]`
      );
      this.innerHTML = $newElement.innerHTML;
      if ($newElement.querySelector("[data-shopify='payment-button']"))
        hasShopifyPaymentButton = true;
    } else {
      $curAreas.forEach(($curArea, areaIndex) => {
        const $newArea = $newAreas[areaIndex];
        let replacingString = "innerHTML";
        if ($newArea.getAttribute(attributes.area)) {
          replacingString = $newArea.getAttribute(attributes.area);
        }
        replacingString.split(",").forEach((replacingValue) => {
          replacingValue = replacingValue.trim();
          if (replacingValue === "innerHTML") {
            $curArea.innerHTML = $newArea.innerHTML;
            if ($newArea.querySelector("[data-shopify='payment-button']"))
              hasShopifyPaymentButton = true;
            return;
          }
          if (!$newArea.hasAttribute(replacingValue)) {
            $curArea.removeAttribute(replacingValue);
            return;
          }
          $curArea.setAttribute(
            replacingValue,
            $newArea.getAttribute(replacingValue)
          );
        });
      });
    }
    if (hasShopifyPaymentButton) window.Shopify?.PaymentButton?.init();
    this.#hydrate();
  }

  #updateAvailability() {
    const newAvailability = {};

    this.#data.product.variants.forEach((variant) => {
      for (let i = 0; i < this.#optionsHierarchy.length; i++) {
        const optionIndex = this.#optionsHierarchy[i];
        const optionName = this.#data.product.options[optionIndex];
        const variantOptionValue = variant.options[optionIndex];

        if (!(optionName in newAvailability)) {
          newAvailability[optionName] = {};
        }
        const valuesAvailability = newAvailability[optionName];

        // if valuesAvailability[variantOptionValue] is false or doesn't exist (undefined)
        if (!valuesAvailability[variantOptionValue]) {
          valuesAvailability[variantOptionValue] = variant.available;
        }

        if (
          variant.options[optionIndex] !==
          this.#optionsValues[optionIndex].value
        ) {
          break;
        }
      }
    });

    const prevAvailability = this.#optionsAvailability;
    this.#optionsAvailability = newAvailability;

    const newAvailabilityKeys = Object.keys(newAvailability);
    if (newAvailabilityKeys.length !== Object.keys(prevAvailability).length)
      return true;

    for (let i = 0; i < newAvailabilityKeys.length; i++) {
      const optionProp = newAvailabilityKeys[i];
      if (!(optionProp in prevAvailability)) return true;

      const newValuesKeys = Object.keys(newAvailability[optionProp]);
      if (
        newValuesKeys.length !==
        Object.keys(prevAvailability[optionProp]).length
      )
        return true;

      for (let j = 0; j < newValuesKeys.length; j++) {
        const valueProp = newValuesKeys[j];
        if (
          newAvailability[optionProp][valueProp] !==
          prevAvailability[optionProp][valueProp]
        )
          return true;
      }
    }

    return false;
  }

  get state() {
    return {
      variantId: this.#variantId,
      optionsValues: this.#optionsValues,
      optionsAvailability: this.#optionsAvailability,
    };
  }
}
customElements.define(ELEMENT_NAME, ProductSection);

})();

/******/ })()
;